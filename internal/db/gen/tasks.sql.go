// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tasks.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getTasksByWorkOrderID = `-- name: GetTasksByWorkOrderID :many
SELECT
  t.id                        AS task_id,
  t.organisation_id           AS task_org_id,
  t.created_at                AS task_created_at,
  t.updated_at                AS task_updated_at,
  t.created_by_id             AS task_created_by_id,
  t.notes                     AS task_notes,
  t.value                     AS task_value,
  t.work_order_id             AS task_work_order_id,
  t.preventive_maintenance_id AS task_preventive_maintenance_id,

  -- TaskBase
  tb.id                       AS task_base_id,
  tb.label                    AS task_base_label,
  tb.task_type                AS task_base_type,

  -- Linked User
  u.id                        AS task_user_id,
  u.name                      AS task_user_name,
  u.email                     AS task_user_email,

  -- Asset
  a.id                        AS task_asset_id,
  a.name                      AS task_asset_name,

  -- Meter
  m.id                        AS task_meter_id,
  m.name                      AS task_meter_name,

  -- PreventiveMaintenance
  pm.id                       AS pm_id,
  pm.name                     AS pm_name,

  -- WorkOrder
  wo.id                       AS work_order_id,
  wo.title                    AS work_order_title,
  wo.status                   AS work_order_status,

  -- Options (aggregated as JSON array)
  COALESCE(
    json_agg(
      DISTINCT jsonb_build_object(
        'id', topt.id,
        'label', topt.label
      )
    ) FILTER (WHERE topt.id IS NOT NULL),
    '[]'
  )                           AS task_options,

  -- Files (aggregated as JSON array)
  COALESCE(
    json_agg(
      DISTINCT jsonb_build_object(
        'id', f.id,
        'filename', f.filename,
        'path', f.path
      )
    ) FILTER (WHERE f.id IS NOT NULL),
    '[]'
  )                           AS task_files

FROM tasks t
JOIN task_bases tb ON tb.id = t.task_base_id
LEFT JOIN users u ON u.id = tb.user_id
LEFT JOIN assets a ON a.id = tb.asset_id
LEFT JOIN meters m ON m.id = tb.meter_id
LEFT JOIN preventive_maintenances pm ON pm.id = t.preventive_maintenance_id
JOIN work_order wo ON wo.id = t.work_order_id AND wo.organisation_id = $1
LEFT JOIN task_options topt ON topt.task_base_id = tb.id
LEFT JOIN task_files tf ON tf.task_id = t.id
LEFT JOIN files f ON f.id = tf.file_id

WHERE t.work_order_id = $2
  AND t.organisation_id = $1

GROUP BY
  t.id, tb.id, u.id, a.id, m.id, pm.id, wo.id
`

type GetTasksByWorkOrderIDParams struct {
	OrganisationID pgtype.UUID `db:"organisation_id" json:"organisation_id"`
	WorkOrderID    pgtype.UUID `db:"work_order_id" json:"work_order_id"`
}

type GetTasksByWorkOrderIDRow struct {
	TaskID                      pgtype.UUID        `db:"task_id" json:"task_id"`
	TaskOrgID                   pgtype.UUID        `db:"task_org_id" json:"task_org_id"`
	TaskCreatedAt               pgtype.Timestamptz `db:"task_created_at" json:"task_created_at"`
	TaskUpdatedAt               pgtype.Timestamptz `db:"task_updated_at" json:"task_updated_at"`
	TaskCreatedByID             pgtype.UUID        `db:"task_created_by_id" json:"task_created_by_id"`
	TaskNotes                   pgtype.Text        `db:"task_notes" json:"task_notes"`
	TaskValue                   pgtype.Text        `db:"task_value" json:"task_value"`
	TaskWorkOrderID             pgtype.UUID        `db:"task_work_order_id" json:"task_work_order_id"`
	TaskPreventiveMaintenanceID pgtype.UUID        `db:"task_preventive_maintenance_id" json:"task_preventive_maintenance_id"`
	TaskBaseID                  pgtype.UUID        `db:"task_base_id" json:"task_base_id"`
	TaskBaseLabel               string             `db:"task_base_label" json:"task_base_label"`
	TaskBaseType                string             `db:"task_base_type" json:"task_base_type"`
	TaskUserID                  pgtype.UUID        `db:"task_user_id" json:"task_user_id"`
	TaskUserName                pgtype.Text        `db:"task_user_name" json:"task_user_name"`
	TaskUserEmail               pgtype.Text        `db:"task_user_email" json:"task_user_email"`
	TaskAssetID                 pgtype.UUID        `db:"task_asset_id" json:"task_asset_id"`
	TaskAssetName               pgtype.Text        `db:"task_asset_name" json:"task_asset_name"`
	TaskMeterID                 pgtype.UUID        `db:"task_meter_id" json:"task_meter_id"`
	TaskMeterName               pgtype.Text        `db:"task_meter_name" json:"task_meter_name"`
	PmID                        pgtype.UUID        `db:"pm_id" json:"pm_id"`
	PmName                      pgtype.Text        `db:"pm_name" json:"pm_name"`
	WorkOrderID                 pgtype.UUID        `db:"work_order_id" json:"work_order_id"`
	WorkOrderTitle              string             `db:"work_order_title" json:"work_order_title"`
	WorkOrderStatus             string             `db:"work_order_status" json:"work_order_status"`
	TaskOptions                 interface{}        `db:"task_options" json:"task_options"`
	TaskFiles                   interface{}        `db:"task_files" json:"task_files"`
}

func (q *Queries) GetTasksByWorkOrderID(ctx context.Context, arg GetTasksByWorkOrderIDParams) ([]GetTasksByWorkOrderIDRow, error) {
	rows, err := q.db.Query(ctx, getTasksByWorkOrderID, arg.OrganisationID, arg.WorkOrderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTasksByWorkOrderIDRow
	for rows.Next() {
		var i GetTasksByWorkOrderIDRow
		if err := rows.Scan(
			&i.TaskID,
			&i.TaskOrgID,
			&i.TaskCreatedAt,
			&i.TaskUpdatedAt,
			&i.TaskCreatedByID,
			&i.TaskNotes,
			&i.TaskValue,
			&i.TaskWorkOrderID,
			&i.TaskPreventiveMaintenanceID,
			&i.TaskBaseID,
			&i.TaskBaseLabel,
			&i.TaskBaseType,
			&i.TaskUserID,
			&i.TaskUserName,
			&i.TaskUserEmail,
			&i.TaskAssetID,
			&i.TaskAssetName,
			&i.TaskMeterID,
			&i.TaskMeterName,
			&i.PmID,
			&i.PmName,
			&i.WorkOrderID,
			&i.WorkOrderTitle,
			&i.WorkOrderStatus,
			&i.TaskOptions,
			&i.TaskFiles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSimpleTasksByWorkOrder = `-- name: ListSimpleTasksByWorkOrder :many
SELECT
  t.id AS id,                                                -- UUID
  tb.label AS title,                                         -- task "title"
  (UPPER(COALESCE(t.value, '')) IN ('COMPLETE','PASS')) AS completed,
  u.name AS assignee_name,
  jsonb_build_object(                                        -- taskBase payload
    'id', tb.id,
    'label', tb.label,
    'taskType', tb.task_type,
    'assetId', tb.asset_id,
    'meterId', tb.meter_id
  ) AS task_base
FROM tasks t
JOIN task_bases tb ON tb.id = t.task_base_id
LEFT JOIN users u ON u.id = tb.user_id
JOIN work_order wo ON wo.id = t.work_order_id AND wo.organisation_id = $1
WHERE t.organisation_id = $1
  AND t.work_order_id   = $2
ORDER BY t.created_at ASC
`

type ListSimpleTasksByWorkOrderParams struct {
	OrganisationID pgtype.UUID `db:"organisation_id" json:"organisation_id"`
	WorkOrderID    pgtype.UUID `db:"work_order_id" json:"work_order_id"`
}

type ListSimpleTasksByWorkOrderRow struct {
	ID           pgtype.UUID `db:"id" json:"id"`
	Title        string      `db:"title" json:"title"`
	Completed    bool        `db:"completed" json:"completed"`
	AssigneeName pgtype.Text `db:"assignee_name" json:"assignee_name"`
	TaskBase     []byte      `db:"task_base" json:"task_base"`
}

func (q *Queries) ListSimpleTasksByWorkOrder(ctx context.Context, arg ListSimpleTasksByWorkOrderParams) ([]ListSimpleTasksByWorkOrderRow, error) {
	rows, err := q.db.Query(ctx, listSimpleTasksByWorkOrder, arg.OrganisationID, arg.WorkOrderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSimpleTasksByWorkOrderRow
	for rows.Next() {
		var i ListSimpleTasksByWorkOrderRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Completed,
			&i.AssigneeName,
			&i.TaskBase,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

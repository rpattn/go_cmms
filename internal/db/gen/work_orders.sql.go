// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: work_orders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const changeWorkOrderStatus = `-- name: ChangeWorkOrderStatus :exec

UPDATE work_order
SET
  status = $1,
  completed_on = CASE WHEN upper($1) = 'COMPLETE'
                      THEN COALESCE(completed_on, now())
                      ELSE NULL
                 END,
  updated_at = now()
WHERE id = $2
  AND organisation_id = $3
`

type ChangeWorkOrderStatusParams struct {
	Status         string      `db:"status" json:"status"`
	WorkOrderID    pgtype.UUID `db:"work_order_id" json:"work_order_id"`
	OrganisationID pgtype.UUID `db:"organisation_id" json:"organisation_id"`
}

// ---------------------------------------------------------------------------
func (q *Queries) ChangeWorkOrderStatus(ctx context.Context, arg ChangeWorkOrderStatusParams) error {
	_, err := q.db.Exec(ctx, changeWorkOrderStatus, arg.Status, arg.WorkOrderID, arg.OrganisationID)
	return err
}

const createWorkOrderFromJSON = `-- name: CreateWorkOrderFromJSON :one
SELECT create_work_order_from_json(
  $1::uuid,
  $2::uuid,
  $3::jsonb
)::uuid AS id
`

type CreateWorkOrderFromJSONParams struct {
	OrganisationID pgtype.UUID `db:"organisation_id" json:"organisation_id"`
	CreatedByID    pgtype.UUID `db:"created_by_id" json:"created_by_id"`
	Payload        []byte      `db:"payload" json:"payload"`
}

func (q *Queries) CreateWorkOrderFromJSON(ctx context.Context, arg CreateWorkOrderFromJSONParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createWorkOrderFromJSON, arg.OrganisationID, arg.CreatedByID, arg.Payload)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteWorkOrderByID = `-- name: DeleteWorkOrderByID :exec
DELETE FROM work_order
WHERE organisation_id = $1
  AND id = $2
`

type DeleteWorkOrderByIDParams struct {
	OrganisationID pgtype.UUID `db:"organisation_id" json:"organisation_id"`
	ID             pgtype.UUID `db:"id" json:"id"`
}

func (q *Queries) DeleteWorkOrderByID(ctx context.Context, arg DeleteWorkOrderByIDParams) error {
	_, err := q.db.Exec(ctx, deleteWorkOrderByID, arg.OrganisationID, arg.ID)
	return err
}

const getWorkOrderDetail = `-- name: GetWorkOrderDetail :one
SELECT
  jsonb_strip_nulls(
    jsonb_build_object(
      'id',                       wo.id,
      'organisation_id',          wo.organisation_id,
      'created_at',               wo.created_at,
      'updated_at',               wo.updated_at,
      'created_by_id',            wo.created_by_id,
      'due_date',                 wo.due_date,
      'priority',                 wo.priority,
      'estimated_duration',       wo.estimated_duration,
      'estimated_start_date',     wo.estimated_start_date,
      'description',              wo.description,
      'title',                    wo.title,
      'required_signature',       wo.required_signature,
      'custom_id',                wo.custom_id,
      'completed_by_id',          wo.completed_by_id,
      'completed_on',             wo.completed_on,
      'status',                   wo.status,
      'archived',                 wo.archived,
      'feedback',                 wo.feedback,
      'first_time_to_react',      wo.first_time_to_react,

      -- NEW: primary worker (object with id + name)
      'primary_worker', (
        SELECT jsonb_build_object(
          'id', u.id,
          'name', u.name,
          'email', u.email
        )
        FROM users u
        WHERE u.id = wo.primary_user_id
      ),

      'image',                    (SELECT jsonb_build_object('id', fimg.id, 'filename', fimg.filename, 'path', fimg.path, 'created_at', fimg.created_at)
                                   FROM files fimg WHERE fimg.id = wo.image_id),
      'signature',                (SELECT jsonb_build_object('id', fsig.id, 'filename', fsig.filename, 'path', fsig.path, 'created_at', fsig.created_at)
                                   FROM files fsig WHERE fsig.id = wo.signature_id),
      'category',                 (SELECT jsonb_build_object('id', c.id, 'name', c.name, 'created_at', c.created_at)
                                   FROM work_order_categories c WHERE c.id = wo.category_id),
      'location',                 (SELECT jsonb_build_object('id', l.id, 'name', l.name, 'created_at', l.created_at)
                                   FROM locations l WHERE l.id = wo.location_id),
      'team',                     (SELECT jsonb_build_object('id', t.id, 'name', t.name, 'created_at', t.created_at)
                                   FROM teams t WHERE t.id = wo.team_id),
      'asset',                    (SELECT jsonb_build_object('id', a.id, 'name', a.name, 'created_at', a.created_at)
                                   FROM assets a WHERE a.id = wo.asset_id),
      'parent_request',           (SELECT jsonb_build_object('id', r.id, 'title', r.title, 'created_at', r.created_at)
                                   FROM requests r WHERE r.id = wo.parent_request_id),
      'parent_preventive_maint',  (SELECT jsonb_build_object('id', pm.id, 'name', pm.name, 'created_at', pm.created_at)
                                   FROM preventive_maintenances pm WHERE pm.id = wo.parent_preventive_maint_id),

      'assigned_to',              COALESCE(
                                     (
                                       SELECT jsonb_agg(
                                         jsonb_build_object(
                                           'user_id', x.user_id,
                                           'name',    u.name,
                                           'email',   u.email
                                         )
                                       )
                                       FROM work_order_assigned_to x
                                       JOIN users u ON u.id = x.user_id
                                       WHERE x.work_order_id = wo.id
                                     ),
                                     '[]'::jsonb
                                   ),

      'customers',                COALESCE(
                                     (SELECT jsonb_agg(jsonb_build_object('id', c2.id, 'name', c2.name, 'email', c2.email, 'created_at', c2.created_at))
                                      FROM work_order_customers woc2
                                      JOIN customers c2 ON c2.id = woc2.customer_id
                                      WHERE woc2.work_order_id = wo.id),
                                     '[]'::jsonb
                                   ),

      'files',                    COALESCE(
                                     (SELECT jsonb_agg(jsonb_build_object('id', f.id, 'filename', f.filename, 'path', f.path, 'created_at', f.created_at))
                                      FROM work_order_files wf
                                      JOIN files f ON f.id = wf.file_id
                                      WHERE wf.work_order_id = wo.id),
                                     '[]'::jsonb
                                   )
    )
  ) AS work_order
FROM work_order wo
WHERE wo.id = $1::uuid
LIMIT 1
`

func (q *Queries) GetWorkOrderDetail(ctx context.Context, dollar_1 pgtype.UUID) ([]byte, error) {
	row := q.db.QueryRow(ctx, getWorkOrderDetail, dollar_1)
	var work_order []byte
	err := row.Scan(&work_order)
	return work_order, err
}

const listWorkOrdersPaged = `-- name: ListWorkOrdersPaged :many
WITH
params AS (
  SELECT
    $1::uuid   AS org_id,
    $2::jsonb AS p
),
page AS (
  SELECT
    org_id,
    COALESCE((p->>'pageNum')::int, 0)  AS page_num,
    COALESCE((p->>'pageSize')::int,50) AS page_size
  FROM params
),
ff AS (
  SELECT jsonb_array_elements(p->'filterFields') AS f
  FROM params
  WHERE (p ? 'filterFields') AND jsonb_typeof(p->'filterFields') = 'array'
),
status_vals AS (
  SELECT COALESCE(array_agg(v), ARRAY[]::text[]) AS vals
  FROM (
    SELECT jsonb_array_elements_text(f->'values') AS v
    FROM ff
    WHERE f->>'field' = 'status' AND COALESCE(f->>'operation','') = 'in'
  ) s
),
archived_eq AS (
  SELECT (f->>'value')::boolean AS archived
  FROM ff
  WHERE f->>'field' = 'archived' AND COALESCE(f->>'operation','') IN ('eq','equals')
  LIMIT 1
),
text_cn AS (
  SELECT NULLIF(btrim(f->>'value'), '') AS term
  FROM ff
  WHERE f->>'field' = 'text' AND COALESCE(f->>'operation','') IN ('cn','contains','like')
  LIMIT 1
),
sort AS (
  SELECT
    lower(NULLIF(p->>'sortField',''))     AS field,
    upper(COALESCE(NULLIF(p->>'direction',''),'DESC')) AS dir
  FROM params
),
filtered AS (
  SELECT w.id, w.organisation_id, w.created_at, w.updated_at, w.created_by_id, w.due_date, w.priority, w.estimated_duration, w.estimated_start_date, w.description, w.title, w.required_signature, w.image_id, w.category_id, w.location_id, w.team_id, w.primary_user_id, w.asset_id, w.custom_id, w.completed_by_id, w.completed_on, w.status, w.signature_id, w.archived, w.parent_request_id, w.feedback, w.parent_preventive_maint_id, w.first_time_to_react
  FROM work_order w
  LEFT JOIN status_vals sv ON TRUE
  LEFT JOIN archived_eq  a  ON TRUE
  LEFT JOIN text_cn      t  ON TRUE
  WHERE
    (w.organisation_id = (SELECT org_id FROM params))
    AND (sv.vals = '{}'::text[] OR w.status = ANY (sv.vals))
    AND (a.archived IS NULL OR w.archived = a.archived)
    AND (
      t.term IS NULL
      OR (
        w.title ILIKE (
          '%' ||
          replace(replace(replace(t.term, E'\\', E'\\\\'), '%', E'\\%'), '_', E'\\_')
          || '%'
        ) ESCAPE E'\\'
        OR w.description ILIKE (
          '%' ||
          replace(replace(replace(t.term, E'\\', E'\\\\'), '%', E'\\%'), '_', E'\\_')
          || '%'
        ) ESCAPE E'\\'
      )
    )
),
ordered AS (
  SELECT
    f.id, f.organisation_id, f.created_at, f.updated_at, f.created_by_id, f.due_date, f.priority, f.estimated_duration, f.estimated_start_date, f.description, f.title, f.required_signature, f.image_id, f.category_id, f.location_id, f.team_id, f.primary_user_id, f.asset_id, f.custom_id, f.completed_by_id, f.completed_on, f.status, f.signature_id, f.archived, f.parent_request_id, f.feedback, f.parent_preventive_maint_id, f.first_time_to_react,
    COUNT(*) OVER()::bigint AS total_rows,
    ROW_NUMBER() OVER (
      ORDER BY
        /* ASC cases */
        CASE WHEN s.field='custom_id'  AND s.dir='ASC'  THEN f.custom_id  END ASC  NULLS LAST,
        CASE WHEN s.field='due_date'   AND s.dir='ASC'  THEN f.due_date   END ASC  NULLS LAST,
        CASE WHEN s.field='created_at' AND s.dir='ASC'  THEN f.created_at END ASC  NULLS LAST,
        CASE WHEN s.field='updated_at' AND s.dir='ASC'  THEN f.updated_at END ASC  NULLS LAST,
        CASE WHEN s.field='priority'   AND s.dir='ASC'  THEN f.priority   END ASC  NULLS LAST,
        CASE WHEN s.field='status'     AND s.dir='ASC'  THEN f.status     END ASC  NULLS LAST,
        CASE WHEN s.field='title'      AND s.dir='ASC'  THEN f.title      END ASC  NULLS LAST,

        /* DESC cases */
        CASE WHEN s.field='custom_id'  AND s.dir='DESC' THEN f.custom_id  END DESC NULLS LAST,
        CASE WHEN s.field='due_date'   AND s.dir='DESC' THEN f.due_date   END DESC NULLS LAST,
        CASE WHEN s.field='created_at' AND s.dir='DESC' THEN f.created_at END DESC NULLS LAST,
        CASE WHEN s.field='updated_at' AND s.dir='DESC' THEN f.updated_at END DESC NULLS LAST,
        CASE WHEN s.field='priority'   AND s.dir='DESC' THEN f.priority   END DESC NULLS LAST,
        CASE WHEN s.field='status'     AND s.dir='DESC' THEN f.status     END DESC NULLS LAST,
        CASE WHEN s.field='title'      AND s.dir='DESC' THEN f.title      END DESC NULLS LAST,

        /* deterministic fallback when no sort provided or ties */
        f.created_at DESC, f.id DESC
    ) AS rn
  FROM filtered f
  CROSS JOIN sort s
),
page_bounds AS (
  SELECT
    (page_num * page_size)             AS off,
    (page_num * page_size + page_size) AS lim
  FROM page
)
SELECT
  o.id, o.organisation_id, o.created_at, o.updated_at, o.created_by_id, o.due_date, o.priority, o.estimated_duration, o.estimated_start_date, o.description, o.title, o.required_signature, o.image_id, o.category_id, o.location_id, o.team_id, o.primary_user_id, o.asset_id, o.custom_id, o.completed_by_id, o.completed_on, o.status, o.signature_id, o.archived, o.parent_request_id, o.feedback, o.parent_preventive_maint_id, o.first_time_to_react, o.total_rows, o.rn
FROM ordered o
JOIN page_bounds b ON TRUE
WHERE o.rn > b.off AND o.rn <= b.lim
ORDER BY o.rn
`

type ListWorkOrdersPagedParams struct {
	OrgID   pgtype.UUID `db:"org_id" json:"org_id"`
	Payload []byte      `db:"payload" json:"payload"`
}

type ListWorkOrdersPagedRow struct {
	ID                      pgtype.UUID        `db:"id" json:"id"`
	OrganisationID          pgtype.UUID        `db:"organisation_id" json:"organisation_id"`
	CreatedAt               pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	CreatedByID             pgtype.UUID        `db:"created_by_id" json:"created_by_id"`
	DueDate                 pgtype.Timestamptz `db:"due_date" json:"due_date"`
	Priority                string             `db:"priority" json:"priority"`
	EstimatedDuration       float64            `db:"estimated_duration" json:"estimated_duration"`
	EstimatedStartDate      pgtype.Timestamptz `db:"estimated_start_date" json:"estimated_start_date"`
	Description             pgtype.Text        `db:"description" json:"description"`
	Title                   string             `db:"title" json:"title"`
	RequiredSignature       bool               `db:"required_signature" json:"required_signature"`
	ImageID                 pgtype.UUID        `db:"image_id" json:"image_id"`
	CategoryID              pgtype.UUID        `db:"category_id" json:"category_id"`
	LocationID              pgtype.UUID        `db:"location_id" json:"location_id"`
	TeamID                  pgtype.UUID        `db:"team_id" json:"team_id"`
	PrimaryUserID           pgtype.UUID        `db:"primary_user_id" json:"primary_user_id"`
	AssetID                 pgtype.UUID        `db:"asset_id" json:"asset_id"`
	CustomID                pgtype.Text        `db:"custom_id" json:"custom_id"`
	CompletedByID           pgtype.UUID        `db:"completed_by_id" json:"completed_by_id"`
	CompletedOn             pgtype.Timestamptz `db:"completed_on" json:"completed_on"`
	Status                  string             `db:"status" json:"status"`
	SignatureID             pgtype.UUID        `db:"signature_id" json:"signature_id"`
	Archived                bool               `db:"archived" json:"archived"`
	ParentRequestID         pgtype.UUID        `db:"parent_request_id" json:"parent_request_id"`
	Feedback                pgtype.Text        `db:"feedback" json:"feedback"`
	ParentPreventiveMaintID pgtype.UUID        `db:"parent_preventive_maint_id" json:"parent_preventive_maint_id"`
	FirstTimeToReact        pgtype.Timestamptz `db:"first_time_to_react" json:"first_time_to_react"`
	TotalRows               int64              `db:"total_rows" json:"total_rows"`
	Rn                      int64              `db:"rn" json:"rn"`
}

// generic text search (title + description)
// NEW: sort options (whitelisted later)
func (q *Queries) ListWorkOrdersPaged(ctx context.Context, arg ListWorkOrdersPagedParams) ([]ListWorkOrdersPagedRow, error) {
	rows, err := q.db.Query(ctx, listWorkOrdersPaged, arg.OrgID, arg.Payload)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWorkOrdersPagedRow
	for rows.Next() {
		var i ListWorkOrdersPagedRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByID,
			&i.DueDate,
			&i.Priority,
			&i.EstimatedDuration,
			&i.EstimatedStartDate,
			&i.Description,
			&i.Title,
			&i.RequiredSignature,
			&i.ImageID,
			&i.CategoryID,
			&i.LocationID,
			&i.TeamID,
			&i.PrimaryUserID,
			&i.AssetID,
			&i.CustomID,
			&i.CompletedByID,
			&i.CompletedOn,
			&i.Status,
			&i.SignatureID,
			&i.Archived,
			&i.ParentRequestID,
			&i.Feedback,
			&i.ParentPreventiveMaintID,
			&i.FirstTimeToReact,
			&i.TotalRows,
			&i.Rn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWorkOrderFromJSON = `-- name: UpdateWorkOrderFromJSON :one
SELECT public.update_work_order_from_json(
  $1::uuid,
  $2::uuid,
  $3::jsonb,
  $4::uuid
)::uuid AS id
`

type UpdateWorkOrderFromJSONParams struct {
	OrganisationID pgtype.UUID `db:"organisation_id" json:"organisation_id"`
	WorkOrderID    pgtype.UUID `db:"work_order_id" json:"work_order_id"`
	Payload        []byte      `db:"payload" json:"payload"`
	UpdatedByID    pgtype.UUID `db:"updated_by_id" json:"updated_by_id"`
}

func (q *Queries) UpdateWorkOrderFromJSON(ctx context.Context, arg UpdateWorkOrderFromJSONParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, updateWorkOrderFromJSON,
		arg.OrganisationID,
		arg.WorkOrderID,
		arg.Payload,
		arg.UpdatedByID,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
